__device__ void atomicDensityObs
	( double *grids, cdouble *obstacle, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		/* 当前格点有障碍物，且密度大于0 */
		if ( obstacle[Index(i,j,k)] eqt MACRO_BOUNDARY_OBSTACLE and grids[Index(i,j,k)] > 0.f )
		{
			int cells  = 0;
			double val = 0; 

			if ( obstacle[Index(i-1,j,k)] eqt MACRO_BOUNDARY_BLANK ) cells++;
			if ( obstacle[Index(i+1,j,k)] eqt MACRO_BOUNDARY_BLANK ) cells++;
			if ( obstacle[Index(i,j-1,k)] eqt MACRO_BOUNDARY_BLANK ) cells++;
			if ( obstacle[Index(i,j+1,k)] eqt MACRO_BOUNDARY_BLANK ) cells++;
			if ( obstacle[Index(i,j,k-1)] eqt MACRO_BOUNDARY_BLANK ) cells++;
			if ( obstacle[Index(i,j,k+1)] eqt MACRO_BOUNDARY_BLANK ) cells++;

			if ( cells > 0 ) val = grids[Index(i,j,k)] / cells;
			else val = 0.f;

			if ( obstacle[Index(i-1,j,k)] eqt MACRO_BOUNDARY_BLANK ) grids[Index(i-1,j,k)] += val;
			if ( obstacle[Index(i+1,j,k)] eqt MACRO_BOUNDARY_BLANK ) grids[Index(i+1,j,k)] += val;
			if ( obstacle[Index(i,j-1,k)] eqt MACRO_BOUNDARY_BLANK ) grids[Index(i,j-1,k)] += val;
			if ( obstacle[Index(i,j+1,k)] eqt MACRO_BOUNDARY_BLANK ) grids[Index(i,j+1,k)] += val;
			if ( obstacle[Index(i,j,k-1)] eqt MACRO_BOUNDARY_BLANK ) grids[Index(i,j,k-1)] += val;
			if ( obstacle[Index(i,j,k+1)] eqt MACRO_BOUNDARY_BLANK ) grids[Index(i,j,k+1)] += val;

			grids[Index(i,j,k)] = 0.f;
		}
	}
};

__device__ void atomicVelocityObs_U
	( double *grids, cdouble *obstacle, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		if ( obstacle[Index(i,j,k)] eqt MACRO_BOUNDARY_OBSTACLE )
		{
			if ( grids[Index(i,j,k)] > 0.f )
			{
				if ( obstacle[Index(i-1,j,k)] eqt MACRO_BOUNDARY_BLANK )
					grids[Index(i-1,j,k)] = grids[Index(i-1,j,k)] -  grids[Index(i,j,k)];
			}
			else
			{
				if ( obstacle[Index(i+1,j,k)] eqt MACRO_BOUNDARY_BLANK )
					grids[Index(i+1,j,k)] = grids[Index(i+1,j,k)] -  grids[Index(i,j,k)];
			}
			grids[Index(i,j,k)] = 0.f;
		}
	}
};

__device__ void atomicVelocityObs_V
	( double *grids, cdouble *obstacle, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		if ( obstacle[Index(i,j,k)] eqt MACRO_BOUNDARY_OBSTACLE )
		{
			if ( grids[Index(i,j,k)] > 0.f )
			{
				if ( obstacle[Index(i,j-1,k)] eqt MACRO_BOUNDARY_BLANK )
					grids[Index(i,j-1,k)] = grids[Index(i,j-1,k)] - grids[Index(i,j,k)];
			}
			else
			{
				if ( obstacle[Index(i,j+1,k)] eqt MACRO_BOUNDARY_BLANK )
					grids[Index(i,j+1,k)] = grids[Index(i,j+1,k)] - grids[Index(i,j,k)];
			}
			grids[Index(i,j,k)] = 0.f;
		}
	}
};

__device__ void atomicVelocityObs_W
	( double *grids, cdouble *obstacle, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		if ( obstacle[Index(i,j,k)] eqt MACRO_BOUNDARY_OBSTACLE )
		{
			if ( grids[Index(i,j,k)] > 0.f )
			{
				if ( obstacle[Index(i,j,k-1)] eqt MACRO_BOUNDARY_BLANK )
					grids[Index(i,j,k-1)] = grids[Index(i,j,k-1)] - grids[Index(i,j,k)];
			}
			else
			{
				if ( obstacle[Index(i,j,k+1)] eqt MACRO_BOUNDARY_BLANK )
					grids[Index(i,j,k+1)] = grids[Index(i,j,k+1)] - grids[Index(i,j,k)];
			}
			grids[Index(i,j,k)] = 0.f;
		}
	}
};

__global__ void kernelObstacle
	( double *grids, cdouble *obstacle, cint field, cint tx, cint ty, cint tz )
{
	switch( field )
	{
	case MACRO_DENSITY:
		atomicDensityObs( grids, obstacle, tx, ty, tz );
		break;

	case MACRO_VELOCITY_U:
		atomicVelocityObs_U( grids, obstacle, tx, ty, tz );
		break;

	case MACRO_VELOCITY_V:
		atomicVelocityObs_V( grids, obstacle, tx, ty, tz );
		break;

	case MACRO_VELOCITY_W:
		atomicVelocityObs_W( grids, obstacle, tx, ty, tz );
		break;

	default:
		break;
	}
};