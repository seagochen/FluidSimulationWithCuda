__global__ void kernelJacobi
	( double *grid_out, cdouble *grid_in, cdouble diffusion, cdouble divisor,
	cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		double div = 0.f;
		if ( divisor <= 0.f ) div = 1.f;
		else div = divisor;

		grid_out [ Index(i,j,k) ] = 
			( grid_in [ Index(i,j,k) ] + diffusion * 
				(
					grid_out [ Index(i-1, j, k) ] + grid_out [ Index(i+1, j, k) ] +
					grid_out [ Index(i, j-1, k) ] + grid_out [ Index(i, j+1, k) ] +
					grid_out [ Index(i, j, k-1) ] + grid_out [ Index(i, j, k+1) ]
				) 
			) / div;
	}
}

__global__ void kernelGridAdvection
	( double *grid_out, cdouble *grid_in, cdouble deltatime, cdouble *u_in, cdouble *v_in, 
	cdouble *w_in, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		double u = i - u_in [ Index(i,j,k) ] * deltatime;
		double v = j - v_in [ Index(i,j,k) ] * deltatime;
		double w = k - w_in [ Index(i,j,k) ] * deltatime;
	
		grid_out [ Index(i,j,k) ] = atomicTrilinear ( grid_in, u, v, w, tx, ty, tz );
	}
};

__global__ void kernelGradient
	( double *div, double *p, cdouble *vel_u, cdouble *vel_v, 
	cdouble *vel_w, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{	
		cdouble h = 1.f / GRIDS_X;

		// previous instantaneous magnitude of velocity gradient = (sum of velocity gradients per axis)/2N:
		div [ Index(i,j,k) ] = -0.5f * h * (
				vel_u [ Index(i+1, j, k) ] - vel_u [ Index(i-1, j, k) ] + // gradient of u
				vel_v [ Index(i, j+1, k) ] - vel_v [ Index(i, j-1, k) ] + // gradient of v
				vel_w [ Index(i, j, k+1) ] - vel_w [ Index(i, j, k-1) ]   // gradient of w
			);
		// zero out the present velocity gradient
		p [ Index(i,j,k) ] = 0.f;
	}
};

__global__ void kernelSubtract
	( double *vel_u, double *vel_v, double *vel_w, cdouble *p, 
	cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		// gradient calculated by neighbors

		vel_u [ Index(i, j, k) ] -= 0.5f * GRIDS_X * ( p [ Index(i+1, j, k) ] - p [ Index(i-1, j, k) ] );
		vel_v [ Index(i, j, k) ] -= 0.5f * GRIDS_X * ( p [ Index(i, j+1, k) ] - p [ Index(i, j-1, k) ] );
		vel_w [ Index(i, j, k) ] -= 0.5f * GRIDS_X * ( p [ Index(i, j, k+1) ] - p [ Index(i, j, k-1) ] );
	}
};

__global__ void kernelAddSource
	( double *density, double *vel_u, double *vel_v, double *vel_w,
	cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	if ( atomicIsNotHalo( i, j, k, tx, ty, tz ) )
	{
		cint half = GRIDS_X / 2;

		if ( j < 3 and i >= half-2 and i <= half+2 and k >= half-2 and k <= half+2 )
		{
			/* add source to grids */
			density[Index(i,j,k)] = DENSITY;

			/* add velocity to grids */
			if ( i < half )
				vel_u[Index(i,j,k)] = -VELOCITY * DELTATIME * DELTATIME;
			elif( i >= half )
				vel_u[Index(i,j,k)] =  VELOCITY * DELTATIME * DELTATIME;

			vel_v[Index(i,j,k)] = VELOCITY;

			if ( k < half )
				vel_w[Index(i,j,k)] = -VELOCITY * DELTATIME * DELTATIME;
			elif ( k >= half )
				vel_w[Index(i,j,k)] =  VELOCITY * DELTATIME * DELTATIME;
		}
	}
};

__global__ void kernelPickData
	( uchar *c, cdouble *bufs, int ofi, int ofj, int ofk,
	cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	ofi = ofi * tx + i;
	ofj = ofj * ty + j;
	ofk = ofk * tz + k;

	/* zero c first */
	c[ ix(ofi,ofj,ofk,VOLUME_X,VOLUME_Y,VOLUME_Z) ] = 0;

	/* append c to volume c */
	int temp = _round( bufs[ Index(i, j, k) ] );
	if ( temp > 0 and temp < 250 )
		c [ ix(ofi,ofj,ofk,VOLUME_X,VOLUME_Y,VOLUME_Z) ] = (uchar) temp;
};

__global__ void kernelInterRootGrids
	( double *dst, cdouble *src, cint pi, cint pj, cint pk, 
	cdouble rate, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	double x = ( pi * GRIDS_X + i ) * rate;
	double y = ( pj * GRIDS_X + j ) * rate;
	double z = ( pk * GRIDS_X + k ) * rate;

	dst[Index(i,j,k)] = atomicTrilinear( src, x, y, z, tx, ty, tz );
};

__global__ void kernelInterLeafGrids
	( double *dst, cdouble *src, cint pi, cint pj, cint pk, 
	cdouble rate, cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	int x = _round( ( pi * GRIDS_X + i ) * rate );
	int y = _round( ( pj * GRIDS_X + j ) * rate );
	int z = _round( ( pk * GRIDS_X + k ) * rate );

	dst[Index(x,y,z)] = src[Index(i,j,k)];
};

__global__ void kernelClearHalo( double *grids, cint tx,
								cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	grids[Index(gst_header,j,k)] = 0.f;
	grids[Index(gst_tailer,j,k)] = 0.f;
	grids[Index(i,gst_header,k)] = 0.f;
	grids[Index(i,gst_tailer,k)] = 0.f;
	grids[Index(i,j,gst_header)] = 0.f;
	grids[Index(i,j,gst_tailer)] = 0.f;
};

__global__ void kernelHandleHalo
	( double *center, cdouble *left, cdouble *right, cdouble *up,
	cdouble *down, cdouble *front, cdouble *back,
	cint tx, cint ty, cint tz )
{
	int i, j, k;
	_thread( &i, &j, &k, tx, ty, tz );

	center[Index(gst_header,j,k)] = left[Index(gst_tailer,j,k)];
	center[Index(gst_tailer,j,k)] = right[Index(gst_header,j,k)];
	center[Index(i,gst_tailer,k)] = up[Index(i,gst_header,k)];
    center[Index(i,gst_header,k)] = down[Index(i,gst_tailer,k)];
	center[Index(i,j,gst_tailer)] = front[Index(i,j,gst_header)];
	center[Index(i,j,gst_header)] = back[Index(i,j,gst_tailer)];

/*	c[cudaIndex3D(gst_header,gst_header,k,VOLUME_X)] = ( c[cudaIndex3D(sim_header,gst_header,k,VOLUME_X)] + c[cudaIndex3D(gst_header,sim_header,k,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_header,gst_tailer,k,VOLUME_X)] = ( c[cudaIndex3D(sim_header,gst_tailer,k,VOLUME_X)] + c[cudaIndex3D(gst_header,sim_tailer,k,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_tailer,gst_header,k,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,gst_header,k,VOLUME_X)] + c[cudaIndex3D(gst_tailer,sim_header,k,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_tailer,gst_tailer,k,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,gst_tailer,k,VOLUME_X)] + c[cudaIndex3D(gst_tailer,sim_tailer,k,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_header,j,gst_header,VOLUME_X)] = ( c[cudaIndex3D(sim_header,j,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_header,j,sim_header,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_header,j,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(sim_header,j,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_header,j,sim_tailer,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_tailer,j,gst_header,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,j,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_tailer,j,sim_header,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(gst_tailer,j,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,j,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_tailer,j,sim_tailer,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(i,gst_header,gst_header,VOLUME_X)] = ( c[cudaIndex3D(i,sim_header,gst_header,VOLUME_X)] + c[cudaIndex3D(i,gst_header,sim_header,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(i,gst_header,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(i,sim_header,gst_tailer,VOLUME_X)] + c[cudaIndex3D(i,gst_header,sim_tailer,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(i,gst_tailer,gst_header,VOLUME_X)] = ( c[cudaIndex3D(i,sim_tailer,gst_header,VOLUME_X)] + c[cudaIndex3D(i,gst_tailer,sim_header,VOLUME_X)] ) / 2.f;
	c[cudaIndex3D(i,gst_tailer,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(i,sim_tailer,gst_tailer,VOLUME_X)] + c[cudaIndex3D(i,gst_tailer,sim_tailer,VOLUME_X)] ) / 2.f;

	c[cudaIndex3D(gst_header,gst_header,gst_header,VOLUME_X)] = ( c[cudaIndex3D(sim_header,gst_header,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_header,sim_header,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_header,gst_header,sim_header,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_header,gst_header,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(sim_header,gst_header,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_header,sim_header,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_header,gst_header,sim_tailer,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_header,gst_tailer,gst_header,VOLUME_X)] = ( c[cudaIndex3D(sim_header,gst_tailer,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_header,sim_tailer,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_header,gst_tailer,sim_header,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_header,gst_tailer,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(sim_header,gst_tailer,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_header,sim_tailer,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_header,gst_tailer,sim_tailer,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_tailer,gst_header,gst_header,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,gst_header,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_tailer,sim_header,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_tailer,gst_header,sim_header,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_tailer,gst_header,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,gst_header,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_tailer,sim_header,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_tailer,gst_header,sim_tailer,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_tailer,gst_tailer,gst_header,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,gst_tailer,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_tailer,sim_tailer,gst_header,VOLUME_X)] + c[cudaIndex3D(gst_tailer,gst_tailer,sim_header,VOLUME_X)] ) / 3.f;
	c[cudaIndex3D(gst_tailer,gst_tailer,gst_tailer,VOLUME_X)] = ( c[cudaIndex3D(sim_tailer,gst_tailer,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_tailer,sim_tailer,gst_tailer,VOLUME_X)] + c[cudaIndex3D(gst_tailer,gst_tailer,sim_tailer,VOLUME_X)] ) / 3.f;
*/
};